# Project Structure

## Root Directory Organization

```
attendance-automation-extension/
├── .kiro/                          # Kiro steering documentation
│   └── steering/                   # Project knowledge and specifications
├── src/                            # TypeScript source code
├── dist/                           # Compiled JavaScript output (build artifacts)
├── icons/                          # Chrome extension icons (16px, 48px, 128px)
├── node_modules/                   # npm dependencies
├── manifest.json                   # Chrome Extension v3 manifest
├── popup.html                      # Extension popup interface HTML
├── webpack.config.js               # Webpack build configuration
├── tsconfig.json                   # TypeScript compiler configuration
├── package.json                    # npm package configuration
├── package-lock.json              # npm dependency lock file
├── CLAUDE.md                       # Claude Code project instructions
└── README.md                       # Project documentation
```

### Key Root Files

- **`manifest.json`**: Chrome Extension v3 manifest defining permissions, entry points, and metadata
- **`popup.html`**: HTML interface for the extension popup with modern styling
- **`webpack.config.js`**: Build configuration with TypeScript compilation and multi-entry bundling
- **`tsconfig.json`**: TypeScript configuration targeting ES2020 with strict type checking
- **`package.json`**: Node.js package configuration with build scripts and dependencies

## Subdirectory Structures

### Source Directory (`src/`)
```
src/
├── types/
│   └── index.ts                    # Centralized TypeScript type definitions
├── utils/
│   └── logger.ts                   # Logging utilities and debug functionality
├── services/
│   └── attendanceService.ts        # Core attendance automation business logic
├── background.ts                   # Chrome Extension background service worker
├── content.ts                      # Content script injected into web pages
└── popup.ts                        # Popup interface logic and event handling
```

### Build Output (`dist/`)
```
dist/                               # Generated by Webpack (not committed)
├── background.js                   # Compiled background script
├── content.js                      # Compiled content script
├── popup.js                        # Compiled popup script
├── *.js.map                        # Source maps for debugging
└── *.d.ts                          # TypeScript declarations (if enabled)
```

### Assets Directory (`icons/`)
```
icons/
├── icon16.png                      # 16x16 px toolbar icon
├── icon48.png                      # 48x48 px extension management icon
└── icon128.png                     # 128x128 px Chrome Web Store icon
```

## Code Organization Patterns

### Chrome Extension Architecture Pattern
```
Extension Components:
├── Background (Service Worker)      # Extension lifecycle management
├── Content Scripts                  # Page interaction and DOM manipulation
├── Popup Interface                  # User configuration and control
└── Manifest Configuration           # Permissions and entry points
```

### Module Organization Strategy
- **Entry Point Pattern**: Each major extension component has its own entry point (`background.ts`, `content.ts`, `popup.ts`)
- **Service Layer Pattern**: Business logic isolated in `services/` directory
- **Utility Pattern**: Shared functionality in `utils/` directory
- **Type Centralization**: All type definitions consolidated in `types/index.ts`

### Dependency Flow
```
popup.ts → attendanceService.ts → utils/logger.ts
    ↓              ↓                       ↓
content.ts → types/index.ts ← background.ts
```

## File Naming Conventions

### TypeScript Files
- **Component Files**: Lowercase with descriptive names (`background.ts`, `content.ts`, `popup.ts`)
- **Service Files**: PascalCase with "Service" suffix (`attendanceService.ts`)
- **Utility Files**: Lowercase descriptive names (`logger.ts`)
- **Type Files**: Lowercase with clear purpose (`index.ts` for main types)

### Directory Naming
- **Lowercase**: All directories use lowercase names
- **Plural Forms**: Directories containing multiple related files use plural names (`types/`, `utils/`, `services/`)
- **Descriptive**: Directory names clearly indicate their purpose and contents

### Build and Configuration Files
- **Kebab Case**: Configuration files use kebab-case (`webpack.config.js`, `package-lock.json`)
- **Standard Names**: Following established conventions (`manifest.json`, `tsconfig.json`, `README.md`)

## Import Organization

### Import Path Strategy
```typescript
// Relative imports for project files
import { AttendanceConfig } from './types/index.js';
import { Logger } from './utils/logger.js';

// Chrome API imports (global)
declare const chrome: typeof import('chrome');
```

### Type Import Patterns
```typescript
// Type-only imports
import type { ProcessResult, TargetRow } from './types/index.js';

// Mixed imports
import { defaultConfig, type AttendanceConfig } from './types/index.js';
```

### Module Resolution
- **Node Resolution**: Using Node.js module resolution strategy
- **Extension Mapping**: TypeScript resolves `.ts` files to `.js` in imports
- **Relative Paths**: All internal imports use relative paths for clarity

## Key Architectural Principles

### Separation of Concerns
- **UI Layer**: Popup interface handles user interaction and configuration
- **Business Logic**: AttendanceService contains core automation algorithms
- **Infrastructure**: Background script manages extension lifecycle and messaging
- **Data Layer**: Chrome Storage API handles configuration persistence

### Type Safety First
- **Strict TypeScript**: Full strict mode enabled with comprehensive type checking
- **Interface-Driven**: All data structures defined as TypeScript interfaces
- **No Implicit Any**: Explicit typing required throughout codebase
- **Type Guards**: Runtime type validation where necessary

### Chrome Extension Best Practices
- **Manifest v3 Compliance**: Using latest Chrome Extension API standards
- **Permission Minimization**: Only requesting necessary permissions
- **Message Passing**: Proper communication between extension components
- **Content Security Policy**: Adhering to CSP requirements for extension security

### Error Handling Strategy
- **Graceful Degradation**: System continues operating when individual components fail
- **Comprehensive Logging**: Detailed error reporting and diagnostic information
- **User Feedback**: Clear error messages and troubleshooting guidance
- **Recovery Mechanisms**: Automatic retry and fallback strategies

### Performance Optimization
- **Lazy Loading**: Components loaded only when needed
- **Efficient DOM Queries**: Optimized selector strategies with fallbacks
- **Memory Management**: Proper cleanup of event listeners and observers
- **Build Optimization**: Webpack configuration for production bundle optimization

### Security Considerations
- **Sandboxed Execution**: Content scripts operate in isolated contexts
- **No eval()**: Avoiding dynamic code execution for security
- **Input Validation**: Sanitizing and validating all user inputs
- **Permission Boundaries**: Respecting Chrome's security model and permissions